# static
- “static方法就是没有this的方法。在static方法内部不能调用非静态方法，反过来是可以的。而且可以在没有创建任何对象的前提下，仅仅通过类本身来调用static方法。这实际上正是static方法的主要用途。”

- 这段话虽然只是说明了static方法的特殊之处，但是可以看出static关键字的基本作用，简而言之，一句话来描述就是：
- 方便在没有创建对象的情况下来进行调用（方法/变量）。
- 很显然，被static关键字修饰的方法或者变量不需要依赖于对象来进行访问，只要类被加载了，就可以通过类名去进行访问。
- static可以用来修饰类的成员方法、类的成员变量，另外可以编写static代码块来优化程序性能。
- 　static方法一般称作静态方法，由于静态方法不依赖于任何对象就可以进行访问，因此对于静态方法来说，是没有this的，因为它不依附于任何对象，既然都没有对象，就谈不上this了。并且由于这个特性，在静态方法中不能访问类的非静态成员变量和非静态成员方法，因为非静态成员方法/变量都是必须依赖具体的对象才能够被调用。
- 但是要注意的是，虽然在静态方法中不能访问非静态成员方法和非静态成员变量，但是在非静态成员方法中是可以访问静态成员方法/变量的。
- 修饰静态代码块 ，静态代码块在类被加载的时候就运行了，而且只运行一次，并且优先于各种代码块以及构造函数。如果一个类中有多个静态代码块，会按照书写顺序依次执行。后面在比较的时候会通过具体实例来证明。
# final 
## 修饰类
- 当用final修饰一个类时，表明这个类不能被继承。也就是说，如果一个类你永远不会让他被继承，就可以用final进行修饰。final类中的成员变量可以根据需要设为final，但是要注意final类中的所有成员方法都会被隐式地指定为final方法。
## 修饰变量
- 对于一个final变量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象。
## 修饰方法
- 当使用final修饰方法时，这个方法将成为最终方法，无法被子类重写。但是，该方法仍然可以被继承。


# synchronized和volatile区别
- synochronizd和volatile关键字区别：
- 1. volatile关键字解决的是变量在多个线程之间的可见性；而sychronized关键字解决的是多个线程之间访问共享资源的同步性。
- 2. volatile只能用于修饰变量，而synchronized可以修饰方法，以及代码块。（volatile是线程同步的轻量级实现，所以volatile性能比synchronized要好，并且随着JDK新版本的发布，sychronized关键字在执行上得到很大的提升，在开发中使用synchronized关键字的比率还是比较大）
- 3. 多线程访问volatile不会发生阻塞，而sychronized会出现阻塞。
- 4. volatile能保证变量在多个线程之间的可见性，但不能保证原子性；而sychronized可以保证原子性，也可以间接保证可见性，因为它会将私有内存和公有内存中的数据做同步。