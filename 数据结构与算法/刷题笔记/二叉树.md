# 路径之和
> 给定一个二叉树与整数sum，找出所有从根节点到叶节点的路径，这些路径上的节点值为sum
## 解题思路
- 遍历二叉树的思想，结合栈的使用
## 代码
<pre>
 static class TreeNode {
        int val;
        TreeNode left;
        TreeNode right;
 
        public TreeNode(int val) {
            this.val = val;
        }
    }
 
    public static void findAllPathes(TreeNode root, int expectedSum) {
        if (root == null) {
            return;
        }
 
        Stack<Integer> path = new Stack<>();
        findPath(root, expectedSum, 0, path);
    }
 
    private static void findPath(TreeNode root, int expectedSum, int sum, Stack<Integer> path) {
        // 累加路径值
        sum += root.val;
        // 将当前节点加入路径中
        path.push(root.val);
        // 如果当前节点是叶子节点(即没有左右子节点)，并且当前累加值等于期望值，则输出路径信息
        if (root.left == null && root.right == null && sum == expectedSum) {
            for (Integer val : path) {
                System.out.print(val + " ");
            }
            System.out.println();
        }
 
        // 如果左子节点不为空，说明不是叶子节点，则继续寻找路径
        if (root.left != null) {
            findPath(root.left, expectedSum, sum, path);
        }
        // 如果右子节点不为空，说明不是叶子节点，则继续寻找路径
        if (root.right != null) {
            findPath(root.right, expectedSum, sum, path);
        }
 
        // 如果当前节点不符合要求，则从路径中移除当前节点
        path.pop();
    }


</pre>
# 最近公共祖先
> 已知二叉树，求二叉树中给定的两个节点最近的公共祖先
<pre>

</pre>
# 二叉树转链表
> 给定一个二叉树，将该二叉树就地转换为单链表，单链表中节点顺序为二叉树前序遍历顺序
<pre>











































































































































































</pre>

# 侧面观察二叉树
# 